#+TITLE: Emacs Configuration
#+AUTHOR: Oguz Serbetci, largly copied from Harry R. Schwartz
#+OPTIONS: toc:nil num:nil

* Sensible Defaults

Use en_US.UTF-8 so that python uses unicode.

#+BEGIN_SRC emacs-lisp
(setenv "LANG" "en_US.UTF-8")
(setenv "LC_ALL" "en_US.UTF-8")
#+END_SRC

* Configure =use-package=

I'm using use-package.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives
               '("marmalade" . "https://marmalade-repo.org/packages/"))

  (package-initialize)

  (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

	(setq use-package-verbose t)
	(setq use-package-always-ensure t)

	(require 'use-package)
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp

  (use-package auto-compile
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)

#+END_SRC

* Tools


#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :ensure t)
#+END_SRC

* Set personal information

** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Oguz Serbetci"
        user-mail-address "oguz.serbetci@gmail.com"
        calendar-latitude 52.5
        calendar-longitude 13.4
        calendar-location-name "Berlin, Germany")
#+END_SRC

* Add =resources= to =load-path=

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+END_SRC

* =evil-mode=

I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
usually not what I want. In particular, it makes working with Coq really
frustrating.

#+BEGIN_SRC emacs-lisp
  (setq evil-want-abbrev-expand-on-insert-exit nil)
#+END_SRC

Use =evil=.

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

Enable =surround= everywhere.

#+BEGIN_SRC emacs-lisp
  (global-evil-surround-mode 1)
#+END_SRC

Bind =C-p= to fuzzy-finding files in the current project.

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
#+END_SRC

Enable evil-escape with =jk=

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :ensure t
    :config
    (evil-escape-mode 1)
    (setq-default evil-escape-key-sequence "jk")
    (setq-default evil-escape-delay 0.2))
#+END_SRC

Use =;= as =:=

#+BEGIN_SRC emacs-lisp
  (define-key evil-motion-state-map ";" 'evil-ex)
  (define-key evil-motion-state-map ":" 'evil-repeat-find-char)
#+END_SRC

* Utility functions

Define a big ol' bunch of handy utility functions.

#+BEGIN_SRC emacs-lisp
  (defun hrs/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
               (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun hrs/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun hrs/visit-last-dired-file ()
    "Open the last file in an open dired buffer."
    (end-of-buffer)
    (previous-line)
    (dired-find-file))

  (defun hrs/visit-last-migration ()
    "Open the last file in 'db/migrate/'. Relies on projectile. Pretty sloppy."
    (interactive)
    (dired (expand-file-name "db/migrate" (projectile-project-root)))
    (hrs/visit-last-dired-file)
    (kill-buffer "migrate"))

  (defun hrs/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun hrs/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+END_SRC

* UI preferences
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (when window-system
    (scroll-bar-mode -1))
#+END_SRC

The default frame title isn't useful. This binds it to the name of the current
project:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Custom dracula theme

I like the dracula theme. I prefer keeping all the characters in the same
side and font, though.

#+BEGIN_SRC emacs-lisp
  (require 'doom)
  (load-theme 'doom-dracula t)
  (doom-themes-org-config)
  (doom-themes-visual-bell-config)
  (use-package nlinum
    :ensure t
    :config
    (setq nlinum-highlight-current-line t))
#+END_SRC

Visually brighten some windows.

#+BEGIN_SRC emacs-lisp
  (use-package solaire-mode
    :hook ((change-major-mode after-revert ediff-prepare-buffer) . turn-on-solaire-mode)
    :config
    (add-hook 'minibuffer-setup-hook #'solaire-mode-in-minibuffer)
    (solaire-mode-swap-bg))
#+END_SRC

Doom mode-line.

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :ensure t
    :defer t
    :hook (after-init . doom-modeline-init))
#+END_SRC

** Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Set default font and configure font resizing

I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+BEGIN_SRC emacs-lisp
  (setq hrs/default-font "Fira Code Retina")
  (setq hrs/default-font-size 12)
  (setq hrs/current-font-size hrs/default-font-size)

  (setq hrs/font-change-increment 1.1)

  (defun hrs/font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat hrs/default-font "-" (number-to-string hrs/current-font-size)))

  (defun hrs/set-font-size ()
    "Set the font to `hrs/default-font' at `hrs/current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (hrs/font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))

  (defun hrs/reset-font-size ()
    "Change font size back to `hrs/default-font-size'."
    (interactive)
    (setq hrs/current-font-size hrs/default-font-size)
    (hrs/set-font-size))

  (defun hrs/increase-font-size ()
    "Increase current font size by a factor of `hrs/font-change-increment'."
    (interactive)
    (setq hrs/current-font-size
          (ceiling (* hrs/current-font-size hrs/font-change-increment)))
    (hrs/set-font-size))

  (defun hrs/decrease-font-size ()
    "Decrease current font size by a factor of `hrs/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq hrs/current-font-size
          (max 1
               (floor (/ hrs/current-font-size hrs/font-change-increment))))
    (hrs/set-font-size))

  (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
  (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
  (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

  (hrs/reset-font-size)
#+END_SRC

** Maintain consistent line height with Unicode characters

Depending on the font, including a Unicode character on a line sometimes makes
that line bizarrely huge, which is super ugly. My preferred font (Inconsolata)
doesn't seem to handle Unicode especially well.

Luckily, the =unicode-fonts= package can totally mitigate this problem! I don't
really know how it works, but I can't argue with the results.

#+BEGIN_SRC emacs-lisp
  ;(unicode-fonts-setup)
#+END_SRC

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode))
#+END_SRC

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+BEGIN_SRC emacs-lisp
  (require 'diff-hl)

  (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
  (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode)
#+END_SRC

* Programming environments

I like shallow indentation (by default), but tabs are displayed as 8 characters by default.
This reduces that.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
#+END_SRC

** CSS and Sass

Indent by 2 spaces.

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :config
    (setq css-indent-offset 2))
#+END_SRC

** Haskell

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+BEGIN_SRC emacs-lisp
  (hrs/append-to-path "~/.cabal/bin")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'haskell-mode-hook
            (lambda ()
              (haskell-doc-mode)
              (turn-on-haskell-indent)))
#+END_SRC

** JavaScript and CoffeeScript

Indent everything by 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (add-hook 'coffee-mode-hook
            (lambda ()
              (yas-minor-mode 1)
              (setq coffee-tab-width 2)))
#+END_SRC

** Lisps

All the lisps have some shared features, so we want to do the same things for
all of them. That includes using =paredit-mode= to balance parentheses (and
more!), =rainbow-delimiters= to color matching parentheses, and highlighting the
whole expression when point is on a paren.

#+BEGIN_SRC emacs-lisp
  (setq lispy-mode-hooks
        '(clojure-mode-hook
          emacs-lisp-mode-hook
          lisp-mode-hook
          scheme-mode-hook))

  (dolist (hook lispy-mode-hooks)
    (add-hook hook (lambda ()
                     (setq show-paren-style 'expression)
                     (paredit-mode)
                     (rainbow-delimiters-mode))))
#+END_SRC

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

** Magit

I bring up the status menu with =C-x g=.

Use =evil= keybindings with =magit=.

The default behavior of =magit= is to ask before pushing. I haven't had any
problems with accidentally pushing, so I'd rather not confirm that every time.

Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
beyond 50 characters.

Enable spellchecking when writing commit messages.

I sometimes use =git= from the terminal, and I'll use =emacsclient --tty= to
write commits. I'd like to be in the insert state when my editor pops open for
that.

I'd like to start in the insert state when writing a commit message.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status)

    :config
    (use-package evil-magit
      :ensure t)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    (add-hook 'git-commit-mode-hook 'turn-on-flyspell)
    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

** Projectile

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds the
easier-to-type =C-c C-v= and =C-c v= to useful searches.

#+BEGIN_SRC emacs-lisp
  (defun hrs/search-project-for-symbol-at-point ()
    "Use `projectile-ag' to search the current project for `symbol-at-point'."
    (interactive)
    (projectile-ag (projectile-symbol-at-point)))

  (global-set-key (kbd "C-c v") 'projectile-ag)
  (global-set-key (kbd "C-c C-v") 'hrs/search-project-for-symbol-at-point)
#+END_SRC

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

#+BEGIN_SRC emacs-lisp
  (setq projectile-switch-project-action 'projectile-dired)
#+END_SRC

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projecile-defined project. This uses the current directory as a
project root (if I'm not in a "real" project).

#+BEGIN_SRC emacs-lisp
  (setq projectile-require-project-root nil)
#+END_SRC

** Python

Add =~/.local/bin= to load path. That's where =virtualenv= is installed, and
we'll need that for =jedi=.

#+BEGIN_SRC emacs-lisp
  (hrs/append-to-path "~/.local/bin")
#+END_SRC

Enable =elpy=. This provides automatic indentation, auto-completion, syntax
checking, etc.

#+BEGIN_SRC emacs-lisp
  (elpy-enable)
#+END_SRC

Use =flycheck= for syntax checking:

#+BEGIN_SRC emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC

Configure Jedi

#+BEGIN_SRC emacs-lisp
  (add-to-list 'company-backends 'company-jedi)
  (add-hook 'python-mode-hook 'jedi:setup)
  (setq jedi:complete-on-dot t)
#+END_SRC

** =sh=

Indent with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

** Slim

If I'm editing Slim templates I'm probably in a Rails project. In that case, I'd
like to still be able to run my tests from a Slim buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'slim-mode-hook 'rspec-mode)
#+END_SRC

** =web-mode=

If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook
            (lambda ()
              (rainbow-mode)
              (rspec-mode)
              (setq web-mode-markup-indent-offset 2)))
#+END_SRC

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+BEGIN_SRC emacs-lisp
  (hrs/add-auto-mode
   'web-mode
   "\\.erb$"
   "\\.html$"
   "\\.php$"
   "\\.rhtml$")
#+END_SRC

** YAML

If I'm editing YAML I'm usually in a Rails project. I'd like to be able to run
the tests from any buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'yaml-mode-hook 'rspec-mode)
#+END_SRC

* Terminal

I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c t") 'multi-term)
#+END_SRC

Use a login shell:

#+BEGIN_SRC emacs-lisp
  (setq multi-term-program-switches "--login")
#+END_SRC

I'd rather not use Evil in the terminal. It's not especially useful (I don't use
vi bindings in xterm) and it shadows useful keybindings (=C-d= for EOF, for
example).

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'term-mode 'emacs)
#+END_SRC

I add a bunch of hooks to =term-mode=:

- I'd like links (URLs, etc) to be clickable.
- Yanking in =term-mode= doesn't quite work. The text from the paste appears in
  the buffer but isn't sent to the shell process. This correctly binds =C-y= and
  middle-click to yank the way we'd expect.
- I bind =M-o= to quickly change windows. I'd like that in terminals, too.
- I don't want to perform =yasnippet= expansion when tab-completing.

#+BEGIN_SRC emacs-lisp
  (defun hrs/term-paste (&optional string)
    (interactive)
    (process-send-string
     (get-buffer-process (current-buffer))
     (if string string (current-kill 0))))

  (add-hook 'term-mode-hook
            (lambda ()
              (goto-address-mode)
              (define-key term-raw-map (kbd "C-y") 'hrs/term-paste)
              (define-key term-raw-map (kbd "<mouse-2>") 'hrs/term-paste)
              (define-key term-raw-map (kbd "M-o") 'other-window)
              (setq yas-dont-activate t)))
#+END_SRC

* Publishing and task management with Org-mode

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Quickly insert a block of elisp:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

Enable spell-checking in Org-mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-indent-mode t)
  (setq org-hide-leading-stars t)
#+END_SRC

** Task and org-capture management

Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/documents/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Dropbox/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file (org-file-path "/home.org"))
  (setq org-index-file (org-file-path "/home.org"))
  (setq org-archive-location
        (concat (org-file-path "/archive.org") "::* From %s"))
#+END_SRC

I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
append them to an "inbox.org" file in my Dropbox. This function lets me import
them easily from that inbox file to my index.

#+BEGIN_SRC emacs-lisp
  (defun hrs/copy-tasks-from-inbox ()
    (when (file-exists-p org-inbox-file)
      (save-excursion
        (find-file org-index-file)
        (goto-char (point-max))
        (insert-file-contents org-inbox-file)
        (delete-file org-inbox-file))))
#+END_SRC

I store all my todos in =~/documents/org/index.org=, so I'd like to derive my
agenda from there.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

States from http://doc.norang.ca/org-mode.html#GettingOrgModeWithGit.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))

#+END_SRC

**** Priorities
     
Use priorities as simple labels in notes.
#+BEGIN_SRC emacs-lisp
  (setq org-priority-faces '((?N . (:foreground "red" :weight 'bold :face "-"))
                             (?P . (:foreground "green" :weight 'bold :face "+"))
                             (?Q . (:foreground "pink" :weight 'bold :face "?"))
                             (?I . (:foreground "red" :weight 'bold :face "!"))))
#+END_SRC
**** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/documents/org/blog-ideas.org=,
- Maintain a todo list in =~/documents/org/index.org=.
- Convert emails into todos to maintain an empty inbox.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("b" "Blog idea"
           entry
           (file (org-file-path "/blog-ideas.org"))
           "* %?\n")

          ("n" "note" entry (file (org-file-path "/refile.org"))
           "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)

          ("e" "Email" entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n\n%a\n\n")

          ("a" "Annotate"
           entry (file "~/org/refile.org")
                 "* [[%^{link}][%^{title}]] :NOTE:\n%U\n%a\n%?" :clock-in t)

          ("s" "Subscribe to an RSS feed"
           plain
           (file "~/documents/rss/urls")
           "%^{Feed URL} \"~%^{Feed name}\"")

          ("t" "Todo"
           entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n")

          ("j" "Journal" entry (file+datetree "~/git/org/diary.org")
           "* %?\n%U\n" :clock-in t :clock-resume t)

          ("h" "Habit"
           entry (file (org-file-path "/refile.org"))
           "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")))

#+END_SRC

When I'm starting an Org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

When refiling an item, I'd like to use ido for completion.

#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

Custom agenda. 

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        (quote (("N" "Notes" tags "NOTE"
                 ((org-agenda-overriding-header "Notes")
                  (org-tags-match-list-sublevels t)))
                ("h" "Habits" tags-todo "STYLE=\"habit\""
                 ((org-agenda-overriding-header "Habits")
                  (org-agenda-sorting-strategy
                   '(todo-state-down effort-up category-keep)))))))
#+END_SRC

**** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

Hit =C-c i= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun hrs/open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (hrs/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'hrs/open-index-file)
#+END_SRC

Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

** Exporting

Allow export to markdown and beamer (for presentations).

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
#+END_SRC

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")

  (setenv "BROWSER" "firefox")
#+END_SRC

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC

**** Exporting projects

I have a few Org project definitions.

#+BEGIN_SRC emacs-lisp
  (set-register ?h (cons 'file "~/org/home.org"))
  (set-register ?p (cons 'file "~/org/capture.org"))
#+END_SRC

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
#+END_SRC

Always use =lualatex= when compiling LaTeX documents.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
  (use-package auctex
    :defer t
    :ensure t
    :config
    (require 'auctex-lua
      :ensure t))
#+END_SRC

Open compiled PDFs in =evince= instead of in the editor.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
        '(lambda ()
           (delete '("\\.pdf\\'" . default) org-file-apps)
           (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s"))))
#+END_SRC

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+END_SRC

Use outline mode.

#+BEGIN_SRC emacs-lisp
  (defun turn-on-outline-minor-mode ()
    (outline-minor-mode 1))
  (add-hook 'LaTeX-mode-hook 'turn-on-outline-minor-mode)
  (add-hook 'latex-mode-hook 'turn-on-outline-minor-mode)
  (setq outline-minor-mode-prefix "\C-c \C-o") ; Or something else
#+END_SRC

Spell checking.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
#+END_SRC

** Add links to Instapaper

I use [[https://instapaper.com][Instapaper]] to store articles I want to read later. The
=instapaper.el= library sends my URLs there.

#+BEGIN_SRC emacs-lisp
  (use-package instapaper
    :ensure t)
#+END_SRC

* Blogging

I maintain a blog written in Jekyll. There are plenty of command-line tools to
automate creating a new post, but staying in my editor minimizes friction and
encourages me to write.

This defines a =hrs/new-blog-post= function, which prompts the user for a title
and creates a new post (with a timestamped and slugged file name) in the blog's
=_posts/= directory. The new post includes appropriate YAML header information.

#+BEGIN_SRC emacs-lisp
  (defvar hrs/jekyll-posts-directory "~/documents/blog/_posts/")
  (defvar hrs/jekyll-post-extension ".md")

  (defun hrs/replace-whitespace-with-hyphens (s)
    (replace-regexp-in-string " " "-" s))

  (defun hrs/replace-nonalphanumeric-with-whitespace (s)
    (replace-regexp-in-string "[^A-Za-z0-9 ]" " " s))

  (defun hrs/remove-quotes (s)
    (replace-regexp-in-string "[\'\"]" "" s))

  (defun hrs/replace-unusual-characters (title)
    "Remove quotes, downcase everything, and replace characters
  that aren't alphanumeric with hyphens."
    (hrs/replace-whitespace-with-hyphens
     (s-trim
      (downcase
       (hrs/replace-nonalphanumeric-with-whitespace
        (hrs/remove-quotes title))))))

  (defun hrs/slug-for (title)
    "Given a blog post title, return a convenient URL slug.
     Downcase letters and remove special characters."
    (let ((slug (hrs/replace-unusual-characters title)))
      (while (string-match "--" slug)
        (setq slug (replace-regexp-in-string "--" "-" slug)))
      slug))

  (defun hrs/timestamped-slug-for (title)
    "Turn a string into a slug with a timestamp and title."
    (concat (format-time-string "%Y-%m-%d")
            "-"
            (hrs/slug-for title)))

  (defun hrs/jekyll-yaml-template (title)
    "Return the YAML header information appropriate for a blog
     post. Include the title, the current date, the post layout,
     and an empty list of tags."
    (concat
     "---\n"
     "title: " title "\n"
     "date: " (format-time-string "%Y-%m-%d") "\n"
     "layout: post\n"
     "# pdf_file: " (hrs/slug-for title) ".pdf\n"
     "tags: []\n"
     "---\n\n"))

  (defun hrs/new-blog-post (title)
    "Create a new blog post in Jekyll."
    (interactive "sPost title: ")
    (let ((post (concat hrs/jekyll-posts-directory
                        (hrs/timestamped-slug-for title)
                        hrs/jekyll-post-extension)))
      (if (file-exists-p post)
          (find-file post)
        (find-file post)
        (insert (hrs/jekyll-yaml-template title)))))
#+END_SRC

This selects and inserts a tag:

#+BEGIN_SRC emacs-lisp
  (defun hrs/existing-blog-tags ()
    "Return a list of all the tags currently used in my blog."
    (split-string (shell-command-to-string "cd ~/documents/blog && rake tags")))

  (defun hrs/insert-blog-tag ()
    "Select one of the current tags and insert it at point."
    (interactive)
    (insert
     (ido-completing-read "Insert tag at point: " (hrs/existing-blog-tags))))
#+END_SRC

* Writing prose

** Look up definitions in Webster 1913

I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.

#+BEGIN_SRC emacs-lisp
  (defun hrs/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (hrs/region-or-word) ""))
     nil
     nil
     (hrs/region-or-word)))

  (defun hrs/dictionary-define-word ()
    (interactive)
    (let* ((word (hrs/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "C-x w") 'hrs/dictionary-define-word)
#+END_SRC

** Look up words in a thesaurus

Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-c s= summons it.

#+BEGIN_SRC emacs-lisp
  (use-package synosaurus
    :ensure t
    :config
    (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
    (add-hook 'after-init-hook #'synosaurus-mode))
#+END_SRC

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- I'd like spell-checking running when editing Markdown.
- Use =pandoc= to render the results.
- Leave the code block font unchanged.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands gfm-mode

    :mode (("\\.md$" . gfm-mode))

    :config
    (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
    (add-hook 'gfm-mode-hook 'flyspell-mode)
    (custom-set-faces
     '(markdown-code-face ((t nil)))))
#+END_SRC

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

Sometimes, though, I don't wanna wrap text. This toggles wrapping with =C-c q=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= it strictly better than the original binding of
=just-one-space=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

Use flycheck in the appropriate buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'latex-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+END_SRC

** Enable region case modification

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC

** Quickly explore my "notes" directory

#+BEGIN_SRC emacs-lisp
  (defun hrs/visit-notes-directory ()
    (interactive)
    (ido-find-file-in-dir "~/documents/notes"))

  (global-set-key (kbd "C-c n") 'hrs/visit-notes-directory)
#+END_SRC

* =dired=

Load up the assorted =dired= extensions.

#+BEGIN_SRC emacs-lisp
  (use-package dired-details)
  ;(use-package dired+)
#+END_SRC

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (use-package dired-open
    :config
    (setq dired-open-extensions
          '(("pdf" . "evince")
            ("mkv" . "vlc")
            ("mp4" . "vlc")
            ("avi" . "vlc"))))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
#+END_SRC

Use "j" and "k" to move around in =dired=.

#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
  (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+END_SRC

Kill buffers of files/directories that are deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

Open a file with an external program (that is, through =xdg-open=) by hitting
=C-c C-o=.

#+BEGIN_SRC emacs-lisp
  (defun dired-xdg-open ()
    "In dired, open the file named on this line."
    (interactive)
    (let* ((file (dired-get-filename nil t)))
      (call-process "xdg-open" nil 0 nil file)))

  (define-key dired-mode-map (kbd "C-c C-o") 'dired-xdg-open)
#+END_SRC

* Editing settings

** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+BEGIN_SRC emacs-lisp
  (defun hrs/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c e") 'hrs/visit-emacs-config)
#+END_SRC

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
#+END_SRC

** Look for executables in =/usr/local/bin=.

#+BEGIN_SRC emacs-lisp
  (hrs/append-to-path "/usr/local/bin")
#+END_SRC

** Use =company-mode= everywhere

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+BEGIN_SRC emacs-lisp
  (save-place-mode t)
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Configure yasnippet

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+END_SRC

I /don’t/ want =ido= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** Configure =ido=

#+BEGIN_SRC emacs-lisp
  (use-package flx-ido
    :ensure t)
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (setq ido-enable-flex-matching t)
  (ido-mode 1)
  (flx-ido-mode 1) ; better/faster matching
  (setq ido-use-faces nil)
  (setq ido-create-new-buffer 'always) ; create new buffer if file does not exist
  (setq completion-ignore-case  t)
#+END_SRC

Order of files.

#+BEGIN_SRC emacs-lisp
  (setq ido-file-extensions-order '(".org" ".py" ".txt" ".emacs" ".tex" ".xml" ".el" ".ini" ".cfg" ".cnf"))
#+END_SRC

** Use =smex= to handle =M-x= with =ido=

#+BEGIN_SRC emacs-lisp
  (smex-initialize)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+END_SRC

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Use projectile everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (use-package engine-mode
    :ensure t
    :config
    (defengine duckduckgo
        "https://duckduckgo.com/?q=%s"
        :keybinding "d")

    (defengine github
        "https://github.com/search?ref=simplesearch&q=%s"
        :keybinding "g")

    (defengine google
        "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

    (defengine rfcs
        "http://pretty-rfc.herokuapp.com/search?q=%s")

    (defengine stack-overflow
        "https://stackoverflow.com/search?q=%s"
        :keybinding "s")

    (defengine wikipedia
        "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
        :keybinding "w")

    (defengine wiktionary
        "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

    (defengine youtube
        "https://www.youtube.com/results?search_query=%s"))

#+END_SRC

* Set custom keybindings

Just a few handy functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "M-o") 'other-window)
#+END_SRC

Remap when working in terminal Emacs.

#+BEGIN_SRC emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+END_SRC
 
